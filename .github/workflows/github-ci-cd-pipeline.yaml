name: CI/CD Pipeline with Mixed SSH Authentication and ALB Integration

on:
  push:
    branches: [ main ]

env:
  DOCKER_IMAGE_NAME: flask-app
  FLASK_ENV: production
  ALB_TARGET_GROUP_ARN: ${{ secrets.ALB_TARGET_GROUP_ARN }}
  AWS_REGION: ${{ secrets.AWS_REGION }}

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v3
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'
        
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install pytest
        
    - name: Set test environment variables
      run: |
        echo "FLASK_SECRET_KEY=test-secret-key-for-github-actions-$(date +%s)" >> $GITHUB_ENV
        echo "FLASK_ENV=testing" >> $GITHUB_ENV
        
    - name: Run tests
      run: |
        python -m pytest tests/ -v --tb=short

  build-and-push:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'

    steps:
    - name: Checkout code
      uses: actions/checkout@v3
    
    - name: Debug Docker Hub credentials
      run: |
        echo "DOCKERHUB_USERNAME: '$DOCKERHUB_USERNAME'"
        echo "DOCKER_IMAGE_NAME: '$DOCKER_IMAGE_NAME'"
        echo "Full image tag would be: $DOCKERHUB_USERNAME/$DOCKER_IMAGE_NAME:latest"
      env:
        DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
        DOCKER_IMAGE_NAME: ${{ env.DOCKER_IMAGE_NAME }}
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v2
    
    - name: Log in to Docker Hub
      uses: docker/login-action@v2
      with:
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_PASSWORD }}
    
    - name: Build and push Docker images
      run: |
        echo "Building Docker image..."
        docker build -t ${{ secrets.DOCKERHUB_USERNAME }}/${{ env.DOCKER_IMAGE_NAME }}:latest .
        docker build -t ${{ secrets.DOCKERHUB_USERNAME }}/${{ env.DOCKER_IMAGE_NAME }}:${{ github.sha }} .
        
        echo "Pushing Docker images..."
        docker push ${{ secrets.DOCKERHUB_USERNAME }}/${{ env.DOCKER_IMAGE_NAME }}:latest
        docker push ${{ secrets.DOCKERHUB_USERNAME }}/${{ env.DOCKER_IMAGE_NAME }}:${{ github.sha }}
        
        echo "âœ… Build and push completed successfully!"

  deploy-to-ec2:
    needs: build-and-push
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'

    steps:
    - name: Check required secrets
      run: |
        echo "Checking if all required secrets are set..."
        echo "BASTION_HOST: ${{ secrets.BASTION_HOST }}"
        echo "BASTION_USERNAME: ${{ secrets.BASTION_USERNAME }}"
        echo "EC2_SSH_KEY length: ${#EC2_SSH_KEY}"
        echo "EC2_USERNAME: ${{ secrets.EC2_USERNAME }}"
        echo "EC2_HOST: ${{ secrets.EC2_HOST }}"
      env:
        EC2_SSH_KEY: ${{ secrets.EC2_SSH_KEY }}
    
    - name: Deploy to EC2 via Bastion
      uses: appleboy/ssh-action@v0.1.6
      with:
        host: ${{ secrets.BASTION_HOST }}
        username: ${{ secrets.BASTION_USERNAME }}
        key: ${{ secrets.BASTION_SSH_KEY }}
        script: |
          echo "ğŸš€ Starting deployment through Bastion host..."
          echo "Bastion host: ${{ secrets.BASTION_HOST }}"
          echo "Target EC2: ${{ secrets.EC2_HOST }}"
          
          cat > /tmp/ec2_deploy_key << 'KEY_EOF'
          ${{ secrets.EC2_SSH_KEY }}
          KEY_EOF
          
          chmod 600 /tmp/ec2_deploy_key
          
          echo "Testing connection to target EC2..."
          ssh -o StrictHostKeyChecking=no -i /tmp/ec2_deploy_key ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }} "echo 'âœ… Connected to target EC2 successfully'"
          
          echo "Executing deployment commands on target EC2..."
          ssh -o StrictHostKeyChecking=no -i /tmp/ec2_deploy_key ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }} << 'DEPLOY_EOF'
          echo "ğŸ“¦ Pulling latest Docker image..."
          docker pull ${{ secrets.DOCKERHUB_USERNAME }}/${{ env.DOCKER_IMAGE_NAME }}:latest
          
          echo "ğŸ›‘ Stopping existing container..."
          docker stop flask-app 2>/dev/null || true
          docker rm flask-app 2>/dev/null || true
          
          echo "ğŸ³ Starting new container..."
          docker run -d \
            -p 5000:5000 \
            -e FLASK_SECRET_KEY='${{ secrets.FLASK_SECRET_KEY }}' \
            -e FLASK_ENV='${{ env.FLASK_ENV }}' \
            --name flask-app \
            --restart unless-stopped \
            ${{ secrets.DOCKERHUB_USERNAME }}/${{ env.DOCKER_IMAGE_NAME }}:latest
          
          echo "â³ Waiting for application to start..."
          # å¢åŠ åº”ç”¨å¥åº·æ£€æŸ¥ï¼Œç¡®ä¿åº”ç”¨çœŸæ­£å¯åŠ¨
          for i in {1..10}; do
            if curl -s --retry 3 --retry-delay 2 http://localhost:5000/api/health > /dev/null 2>&1; then
              echo "âœ… Application health check passed!"
              break
            fi
            echo "Attempt $i/10: Application not ready yet..."
            sleep 5
            if [ $i -eq 10 ]; then
              echo "âŒ Application failed to start within 50 seconds"
              echo "ğŸ“ Application logs:"
              docker logs flask-app || echo "No logs available"
              exit 1
            fi
          done
          
          echo "âœ… Deployment completed!"
          echo "ğŸ“Š Container status:"
          docker ps -a --filter "name=flask-app"
          
          echo "ğŸ“ Application logs (last 20 lines):"
          docker logs flask-app --tail 20 2>/dev/null || echo "No logs available yet"
          
          echo "ğŸŒ Final health check:"
          curl -s -o /dev/null -w "HTTP Status: %{http_code}\n" http://localhost:5000/api/health || echo "Health check failed"
          DEPLOY_EOF
          
          rm -f /tmp/ec2_deploy_key
          
          echo "ğŸ‰ Deployment through Bastion finished successfully!"

  register-with-alb:
    needs: deploy-to-ec2
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'

    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Verify AWS connectivity
      run: |
        echo "Testing AWS connectivity..."
        aws sts get-caller-identity
        echo "âœ… AWS connectivity test passed"

    - name: Get EC2 Instance ID by Private IP
      id: get-instance-id
      run: |
        echo "Looking for EC2 instance with private IP: ${{ secrets.EC2_PRIVATE_IP }}"
        
        INSTANCE_ID=$(aws ec2 describe-instances \
          --filters \
            "Name=private-ip-address,Values=${{ secrets.EC2_PRIVATE_IP }}" \
            "Name=instance-state-name,Values=running" \
          --query "Reservations[].Instances[].InstanceId" \
          --output text)
        
        if [ -z "$INSTANCE_ID" ]; then
          echo "âŒ ERROR: Could not find running EC2 instance with private IP: ${{ secrets.EC2_PRIVATE_IP }}"
          echo "Available instances in region:"
          aws ec2 describe-instances \
            --query "Reservations[].Instances[].[InstanceId, PrivateIpAddress, State.Name]" \
            --output table
          exit 1
        fi

        echo "âœ… Found Instance ID: $INSTANCE_ID"
        echo "INSTANCE_ID=$INSTANCE_ID" >> $GITHUB_OUTPUT

    - name: Verify Target Group exists
      run: |
        echo "Verifying Target Group existence: ${{ env.ALB_TARGET_GROUP_ARN }}"
        
        TARGET_GROUP_INFO=$(aws elbv2 describe-target-groups \
          --target-group-arns "${{ env.ALB_TARGET_GROUP_ARN }}" \
          --query "TargetGroups[0].[TargetGroupName, Protocol, Port, VpcId]" \
          --output text 2>/dev/null) || true
        
        if [ -z "$TARGET_GROUP_INFO" ]; then
          echo "âŒ ERROR: Target Group not found or inaccessible: ${{ env.ALB_TARGET_GROUP_ARN }}"
          echo "Available Target Groups in region:"
          aws elbv2 describe-target-groups \
            --query "TargetGroups[].[TargetGroupArn, TargetGroupName]" \
            --output table
          exit 1
        fi

        echo "âœ… Target Group verified: $TARGET_GROUP_INFO"

    - name: Check ALB and Target Group configuration
      id: alb-config-check
      run: |
        echo "ğŸ” Checking ALB and Target Group configuration..."
        
        # è·å–ç›®æ ‡ç»„å…³è”çš„ALBä¿¡æ¯
        TARGET_GROUP_ARN="${{ env.ALB_TARGET_GROUP_ARN }}"
        ALB_ARN=$(aws elbv2 describe-target-groups \
          --target-group-arns "$TARGET_GROUP_ARN" \
          --query "TargetGroups[0].LoadBalancerArns[0]" \
          --output text 2>/dev/null || echo "")
        
        if [ -z "$ALB_ARN" ]; then
          echo "âŒ Target Group is not associated with any ALB"
          exit 1
        fi
        
        echo "âœ… Target Group is associated with ALB: $(echo $ALB_ARN | cut -d'/' -f2)"
        echo "ALB_ARN=$ALB_ARN" >> $GITHUB_ENV
        
        # æ£€æŸ¥ç›‘å¬å™¨é…ç½®
        echo "ğŸ“¡ ALB Listeners:"
        aws elbv2 describe-listeners \
          --load-balancer-arn "$ALB_ARN" \
          --query "Listeners[].[ListenerArn, Port, Protocol]" \
          --output table
        
        # æ£€æŸ¥ç›‘å¬å™¨è§„åˆ™æ˜¯å¦æŒ‡å‘ç›®æ ‡ç»„
        LISTENER_FOUND=false
        for LISTENER_ARN in $(aws elbv2 describe-listeners --load-balancer-arn "$ALB_ARN" --query "Listeners[].ListenerArn" --output text); do
          echo "ğŸ“‹ Checking rules for listener: $(echo $LISTENER_ARN | cut -d'/' -f2)"
          RULES=$(aws elbv2 describe-rules \
            --listener-arn "$LISTENER_ARN" \
            --query "Rules[].Actions[].TargetGroupArn" \
            --output text)
          
          if echo "$RULES" | grep -q "$TARGET_GROUP_ARN"; then
            echo "âœ… Target Group found in listener rules"
            LISTENER_FOUND=true
          else
            echo "â„¹ï¸  Target Group NOT found in this listener's rules"
          fi
        done
        
        if [ "$LISTENER_FOUND" = false ]; then
          echo "âš ï¸  WARNING: Target Group not found in any listener rules"
          echo "This may cause the 'unused' status if no traffic is routed to this target group"
        fi

    - name: Verify Security Group configuration
      run: |
        echo "ğŸ”’ Checking Security Group configuration..."
        
        # è·å–å®ä¾‹çš„å®‰å…¨ç»„
        INSTANCE_ID="${{ steps.get-instance-id.outputs.INSTANCE_ID }}"
        SECURITY_GROUPS=$(aws ec2 describe-instances \
          --instance-ids "$INSTANCE_ID" \
          --query "Reservations[0].Instances[0].SecurityGroups[].GroupId" \
          --output text)
        
        echo "Instance Security Groups: $SECURITY_GROUPS"
        
        # æ£€æŸ¥å®‰å…¨ç»„æ˜¯å¦å…è®¸5000ç«¯å£è®¿é—®
        PORT_OPEN=false
        for SG_ID in $SECURITY_GROUPS; do
          echo "ğŸ“‹ Checking Security Group $SG_ID for port 5000 access..."
          PORT_RULES=$(aws ec2 describe-security-groups \
            --group-ids "$SG_ID" \
            --query "SecurityGroups[0].IpPermissions[?ToPort==\`5000\`].[FromPort, ToPort, IpRanges[].CidrIp]" \
            --output text)
          
          if [ -n "$PORT_RULES" ]; then
            echo "âœ… Port 5000 is open in Security Group $SG_ID"
            PORT_OPEN=true
          else
            echo "â„¹ï¸  Port 5000 not explicitly open in Security Group $SG_ID"
          fi
        done
        
        if [ "$PORT_OPEN" = false ]; then
          echo "âš ï¸  WARNING: Port 5000 may not be open to ALB traffic"
          echo "ALB requires access to instance port 5000 for health checks and traffic"
        fi

    - name: Check current target health status
      run: |
        echo "Checking current targets in target group..."
        
        CURRENT_TARGETS=$(aws elbv2 describe-target-health \
          --target-group-arn "${{ env.ALB_TARGET_GROUP_ARN }}" \
          --query "TargetHealthDescriptions[].[Target.Id, TargetHealth.State, TargetHealth.Reason]" \
          --output table 2>/dev/null) || true
        
        if [ -n "$CURRENT_TARGETS" ]; then
          echo "Current targets in group:"
          echo "$CURRENT_TARGETS"
        else
          echo "No targets currently registered in this group"
        fi

    - name: Register EC2 instance with ALB Target Group
      run: |
        echo "ğŸš€ Registering instance ${{ steps.get-instance-id.outputs.INSTANCE_ID }} with ALB Target Group"
        echo "Target Group ARN: ${{ env.ALB_TARGET_GROUP_ARN }}"
        
        # å…ˆæ£€æŸ¥æ˜¯å¦å·²ç»æ³¨å†Œ
        EXISTING_TARGET=$(aws elbv2 describe-target-health \
          --target-group-arn "${{ env.ALB_TARGET_GROUP_ARN }}" \
          --targets "Id=${{ steps.get-instance-id.outputs.INSTANCE_ID }}" \
          --query "TargetHealthDescriptions[0].Target.Id" \
          --output text 2>/dev/null || echo "")
        
        if [ "$EXISTING_TARGET" = "${{ steps.get-instance-id.outputs.INSTANCE_ID }}" ]; then
          echo "â„¹ï¸  Instance is already registered in target group, deregistering first..."
          aws elbv2 deregister-targets \
            --target-group-arn "${{ env.ALB_TARGET_GROUP_ARN }}" \
            --targets "Id=${{ steps.get-instance-id.outputs.INSTANCE_ID }}"
          sleep 5
        fi
        
        aws elbv2 register-targets \
          --target-group-arn "${{ env.ALB_TARGET_GROUP_ARN }}" \
          --targets "Id=${{ steps.get-instance-id.outputs.INSTANCE_ID }}"
        
        echo "âœ… Registration command completed successfully"

    - name: Wait for target to become healthy
      id: health-check
      run: |
        echo "â³ Waiting for target to become healthy. This may take 2-3 minutes..."
        MAX_ATTEMPTS=18  # å¢åŠ åˆ°18æ¬¡å°è¯•ï¼ˆ3åˆ†é’Ÿï¼‰
        ATTEMPT=1
        SLEEP_DURATION=10
        
        while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
          echo "Health check attempt $ATTEMPT/$MAX_ATTEMPTS (waiting ${SLEEP_DURATION}s between checks)..."
          
          HEALTH_INFO=$(aws elbv2 describe-target-health \
            --target-group-arn "${{ env.ALB_TARGET_GROUP_ARN }}" \
            --targets "Id=${{ steps.get-instance-id.outputs.INSTANCE_ID }}" \
            --query "TargetHealthDescriptions[0].[Target.Id, TargetHealth.State, TargetHealth.Reason]" \
            --output text 2>/dev/null) || HEALTH_INFO=""
          
          if [ -n "$HEALTH_INFO" ]; then
            INSTANCE_ID=$(echo $HEALTH_INFO | awk '{print $1}')
            HEALTH_STATUS=$(echo $HEALTH_INFO | awk '{print $2}')
            HEALTH_REASON=$(echo $HEALTH_INFO | awk '{print $3}')
            
            echo "Health status: $HEALTH_STATUS"
            if [ -n "$HEALTH_REASON" ] && [ "$HEALTH_REASON" != "None" ]; then
              echo "Health reason: $HEALTH_REASON"
            fi
            
            # å¤„ç†ä¸åŒçš„çŠ¶æ€
            if [ "$HEALTH_STATUS" = "healthy" ]; then
              echo "ğŸ‰ Target is healthy and ready to serve traffic!"
              ALB_DNS=$(aws elbv2 describe-load-balancers \
                --query "LoadBalancers[?contains(LoadBalancerArn,'$(echo $ALB_ARN | cut -d':' -f6)')].DNSName" \
                --output text)
              echo "ALB_URL=$ALB_DNS" >> $GITHUB_ENV
              exit 0
            elif [ "$HEALTH_STATUS" = "unused" ]; then
              echo "â„¹ï¸  Target is registered but not receiving traffic yet (normal during warm-up)"
              # ç»§ç»­ç­‰å¾…ï¼Œä¸è¦é€€å‡º
            elif [ "$HEALTH_STATUS" = "unhealthy" ]; then
              echo "âŒ Target is unhealthy. Reason: $HEALTH_REASON"
              echo "Please check:"
              echo "1. Flask application is running on port 5000"
              echo "2. Security groups allow traffic from ALB to EC2 instance"
              echo "3. Application health check endpoint is working"
              
              # è·å–è¯¦ç»†çš„å¥åº·æ£€æŸ¥ä¿¡æ¯
              aws elbv2 describe-target-health \
                --target-group-arn "${{ env.ALB_TARGET_GROUP_ARN }}" \
                --targets "Id=${{ steps.get-instance-id.outputs.INSTANCE_ID }}" \
                --output json
              exit 1
            elif [ "$HEALTH_STATUS" = "initial" ]; then
              echo "â³ Target is in initial state (registration in progress)"
            elif [ "$HEALTH_STATUS" = "draining" ]; then
              echo "ğŸ”„ Target is draining connections"
            fi
          else
            echo "Health information not available yet..."
          fi
          
          sleep $SLEEP_DURATION
          ATTEMPT=$((ATTEMPT + 1))
        done
        
        echo "âŒ ERROR: Target did not become healthy within $((MAX_ATTEMPTS * SLEEP_DURATION)) seconds"
        echo "Possible reasons:"
        echo "1. ALB listener not configured to send traffic to this target group"
        echo "2. Application not responding on port 5000"
        echo "3. Network/Security Group issues"
        echo "4. Target Group health check configuration issues"
        
        # è·å–æ›´è¯¦ç»†çš„è¯Šæ–­ä¿¡æ¯
        echo "ğŸ” Detailed diagnostic information:"
        aws elbv2 describe-target-health \
          --target-group-arn "${{ env.ALB_TARGET_GROUP_ARN }}" \
          --targets "Id=${{ steps.get-instance-id.outputs.INSTANCE_ID }}" \
          --output json
        
        # æ£€æŸ¥ç›®æ ‡ç»„å¥åº·æ£€æŸ¥é…ç½®
        echo "ğŸ“‹ Target Group health check configuration:"
        aws elbv2 describe-target-groups \
          --target-group-arns "${{ env.ALB_TARGET_GROUP_ARN }}" \
          --query "TargetGroups[0].HealthCheck" \
          --output json
        
        exit 1

    - name: Display ALB DNS name
      if: success()
      run: |
        echo "ğŸŒ Application is now live and accessible through ALB"
        echo "ALB DNS Name: $ALB_URL"
        echo "Full URL: http://$ALB_URL"
        echo "Health Check URL: http://$ALB_URL/api/health"

  notify:
    runs-on: ubuntu-latest
    needs: [deploy-to-ec2, register-with-alb]
    if: always()

    steps:
    - name: Determine deployment status
      id: check-status
      run: |
        if [ "${{ needs.deploy-to-ec2.result }}" = "success" ] && [ "${{ needs.register-with-alb.result }}" = "success" ]; then
          echo "STATUS=success" >> $GITHUB_OUTPUT
          echo "MESSAGE=âœ… CI/CD Pipeline completed successfully!" >> $GITHUB_OUTPUT
          echo "ALB_URL=$ALB_URL" >> $GITHUB_OUTPUT
        else
          echo "STATUS=failure" >> $GITHUB_OUTPUT
          echo "MESSAGE=âŒ CI/CD Pipeline failed! Check job logs for details." >> $GITHUB_OUTPUT
        fi

    - name: Notify deployment status
      run: |
        echo "${{ steps.check-status.outputs.MESSAGE }}"
        echo "ğŸ“¦ Image: ${{ secrets.DOCKERHUB_USERNAME }}/${{ env.DOCKER_IMAGE_NAME }}:latest"
        echo "ğŸ”— Commit: ${{ github.sha }}"
        echo "ğŸŒ Deployed to EC2: ${{ secrets.EC2_HOST }}"
        echo "âš–ï¸  ALB Target Group: $(echo ${{ env.ALB_TARGET_GROUP_ARN }} | cut -d'/' -f2)"
        
        if [ "${{ steps.check-status.outputs.STATUS }}" = "success" ]; then
          echo "ğŸ‰ Application is now serving production traffic through ALB"
          echo "ğŸ”— ALB URL: http://${{ steps.check-status.outputs.ALB_URL }}"
        else
          echo "ğŸ’¥ Deployment failed at:"
          echo "   - deploy-to-ec2: ${{ needs.deploy-to-ec2.result }}"
          echo "   - register-with-alb: ${{ needs.register-with-alb.result }}"
          exit 1
        fi